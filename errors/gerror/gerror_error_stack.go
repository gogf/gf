// Copyright GoFrame Author(https://goframe.org). All Rights Reserved.
//
// This Source Code Form is subject to the terms of the MIT License.
// If a copy of the MIT was not distributed with this file,
// You can obtain one at https://github.com/gogf/gf.

package gerror

import (
	"bytes"
	"math"
	"runtime"
	"strconv"
	"strings"

	"github.com/gogf/gf/v2/internal/consts"
	"github.com/gogf/gf/v2/internal/errors"
)

// Stack returns the error stack information as string.
func (err *Error) Stack() string {
	if err == nil {
		return ""
	}
	var (
		id               = 1
		count            = 0
		stackInfos       = make([]stackInfo, 0, 4)
		isStackModeBrief = errors.IsStackModeBrief()
	)
	tsi := getErrorStackInfo(err, id, isStackModeBrief)
	stackInfos = append(stackInfos, tsi)
	count += int(tsi.count)

	temp := err.error
	for temp != nil {
		switch x := temp.(type) {
		case *Error:
			id++
			tsi = getErrorStackInfo(x, id, isStackModeBrief)
			stackInfos = append(stackInfos, tsi)
			count += int(tsi.count) + len("\n")
			temp = x.error
		default:
			temp = nil
			count += len(x.Error()) + len("\n")
			stackInfos = append(stackInfos, stackInfo{
				bufs:    nil,
				errLine: []byte(x.Error()),
				count:   0,
			})
		}
	}

	var sb = getBytesBuffer()
	sb.Grow(count)
	defer putBytesBuffer(sb)

	for _, si := range stackInfos {
		sb.Write(si.errLine)
		for k, b := range si.bufs {
			sb.Write(getLineIdPrefix(k))
			sb.Write(b)
		}
		sb.WriteByte('\n')
	}
	return sb.String()
}

// Stack returns the error stack information as string.
func (err *Error) stackWithBuffer(buffer *bytes.Buffer, errError string) {
	if err == nil {
		return
	}
	var (
		id               = 1
		count            = 0
		stackInfos       = make([]stackInfo, 0, 4)
		isStackModeBrief = errors.IsStackModeBrief()
	)
	errStackInfo := getErrorStackInfo(err, id, isStackModeBrief)
	stackInfos = append(stackInfos, errStackInfo)
	count += int(errStackInfo.count) + len("\n")

	temp := err.error
	for temp != nil {
		switch x := temp.(type) {
		case *Error:
			id++
			errStackInfo = getErrorStackInfo(x, id, isStackModeBrief)
			stackInfos = append(stackInfos, errStackInfo)
			count += int(errStackInfo.count) + len("\n")
			temp = x.error
		default:
			temp = nil
			count += len(x.Error()) + len("\n")
			stackInfos = append(stackInfos, stackInfo{
				bufs:    nil,
				errLine: []byte(x.Error()),
				count:   0,
			})
		}
	}

	if len(errError) > 0 {
		buffer.Grow(count + len(errError) + 1)
		buffer.WriteString(errError)
		buffer.WriteString("\n")
	} else {
		buffer.Grow(count)
	}

	for _, si := range stackInfos {
		buffer.Write(si.errLine)
		for k, buf := range si.bufs {
			buffer.Write(getLineIdPrefix(k))
			buffer.Write(buf)
		}
		buffer.WriteByte('\n')
	}
}

type stackInfo struct {
	bufs [][]byte
	// 1. error1
	// 2. error2
	// ...
	errLine []byte
	// for _,buf:=range len(bufs) {
	//		count += len(buf)
	// }
	// Calculate the space that needs to be expanded to avoid further expansion during writing
	count int32
}

func getErrorStackInfo(err *Error, id int, isStackModeBrief bool) (errStackInfo stackInfo) {
	var (
		count = getIntLength(id) + len(". ") + len(err.text)
		pcs   = err.stack
	)
	errStackInfo.bufs = make([][]byte, 0, len(pcs))
	for i, pc := range pcs {
		// count += len("\n\t%d). ")
		count += len("\n\t") + getIntLength(i+1) + len("). ")

		stackObj := cacheStackTrace.getStackObject(pc)
		if stackObj.stackBuf == nil {
			stackObj = addStackInfoToCache(pc)
		}
		count += len(stackObj.stackBuf)

		// 1. If it is in brief mode and includes the path of the [goframe] package, skip it directly
		//    isStackBrief && flag == stackObjectFlagStackFilterKeyForGoFrame
		// 2. Path containing [gerror] package, skip
		//    flag == stackObjectFlagStackFilterKeyLocal
		// TODO: Ignore the automatically generated package path and goroot path?
		// ignore autogenerated<>  ?
		// ignore go root paths    ?

		if isStackModeBrief {
			if stackObj.flag == stackObjectFlagStackFilterKeyForGoFrame {
				continue
			}
			errStackInfo.bufs = append(errStackInfo.bufs, stackObj.stackBuf)
		} else if stackObj.flag == stackObjectFlagStackFilterKeyLocal {
			// continue
		} else {
			errStackInfo.bufs = append(errStackInfo.bufs, stackObj.stackBuf)
		}
		// ignore autogenerated<>  ?
		// ignore go root paths    ?
	}

	// 1. Internal Error
	// 2. Invalid Parameter
	// ...
	errStackInfo.errLine = []byte(getIdStr(id) + err.text)
	errStackInfo.count = int32(count)
	return errStackInfo
}

func addStackInfoToCache(pc uintptr) stackObject {
	pcs := [1]uintptr{pc}
	f, _ := runtime.CallersFrames(pcs[:]).Next()
	buf := []byte(f.Function + "\n\t\t" + f.File + ":" + strconv.Itoa(f.Line))

	// fn = runtime.FuncForPC(pc - 1)
	// file, line = fn.FileLine(pc - 1)
	// buf := []byte(fn.Name() + "\n\t\t" + file + ":" + strconv.Itoa(line))

	const gf_path = consts.StackFilterKeyForGoFrame
	flag := stackObjectFlag(0)
	if strings.Contains(f.File, gf_path) {
		// package path stack filtering.
		if strings.Contains(f.File, stackFilterKeyLocal) {
			// continue
			flag = stackObjectFlagStackFilterKeyLocal
		} else {
			// continue
			flag = stackObjectFlagStackFilterKeyForGoFrame
		}
	}
	stackObj := stackObject{
		stackBuf: buf,
		flag:     flag,
	}
	cacheStackTrace.addStackObject(pc, stackObj)
	return stackObj
}

// 0-9     = 1
// 10-99   = 2
// 100-999 = 3
// ...
func getIntLength(n int) int {
	if n < 10 {
		return 1
	}
	if n < 100 {
		return 2
	}
	if n < 1000 {
		return 3
	}
	if n < 10000 {
		return 4
	}
	if n < 100000 {
		return 5
	}
	return int(math.Log10(float64(n)) + 1)
}
